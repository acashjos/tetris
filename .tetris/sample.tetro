# maps should be ordered. If so, I don't have to deal with arrays of single property objects
# think of a way to do it. Either add a Utility class that wrap around single property obj arrays
# Or, modify yaml reader to return Maps instead of objects. this way the yaml document itself will look cleaner. (leading `-`s won't be required)

$commentLimitter:        #.// defines the comment format relevant to the templated language. Default is `/*` and `*/` 
    - /*$
    - $*/
$attachments:    #// list of files in which reference to the generated file is to be attached and rules for attachment
    ${hook-path}: # can be a hardcoded path also
        anchor: 
            - /*<-- models -->*/
            - /*<-- models-end -->*/
        glue: ;$endl    #//default is $endl
        hook: require('${p1}')${hook-pattern}
        matchIndent: false

$params:        #// command line params
    - p1: Parameter 1
    - p2: Parameter 2
    - hook-path: Path to file where to hook
    - insert-at: pattern of string to attach hook at
    - test-empty: 

#$remember: 
#    - hook-path
#    - insert-at
#$required: 
#    - hook-path
#    - insert-at

$case:
    ${p1},${p2},${stackPosition}:
        _,*,0: 
            - $throw: param 1 can't be empty
        _,*:
            - $print: Recursion failed
            - $return: ${NULL}
        *,test:
            - var1: ${sample 55 68}
            - temp_val: value


#//at the end of execution or when $release called (first occurance only) `${result}` is written to $destination
#//if this field is empty during $release, it'll throw an error and revert all changes.

$destination: path/to/destination/can/must/be/relative/${p1}.js


::end


/**  loop/if suggestion 1 **/

::if boolean_variable

if_block code here
::endif

::loop
::set input ${evalExp} # this could be a method call, may be a stdin readline
::set should_continue_loop ${evalB input}
should_continue_loop is a variable and will have the evalExp value
looping code here. This will act as a do-while loop until the while statement comes up.
::while should_continue_loop
everything after `while` is treated as a normal while loop.
while statement takes one variable which it checks for truth.

::endloop


/**  suggestion 2 : loop and if combined**/
::repeat
::set input ${evalExp} # this could be a method call, may be a stdin readline
::set should_continue_loop ${evalB ! input}
this repeat block loops until a breakif statement passes.
::breakif should_continue_loop
to act as a normal if block put breakif at the top, just after loop statement.
some content here

::endrepeat

;-P
/*$p1$*/
/*$temp_val$*/
/*<-- insertHere -->*/
;-P




/*sys keywords:
$null, ${varName}, $endl
STD functions:
**************
$print       : Prints a text message to stdout
$remember    : caches the param value to a disk store. It'll be used next time if no value is provided. 
             !! Do not use this for params dependant on other params
$return      : Stops execution and returns a string value. Technically, each template files is converted to a JS function equivalent. Lets called it a generator function
$import      : Imports a JS file into this namespace. All functions will be available as local functions. Fns with same name will be overridden in the order of import
$call        : call a function  
$throw       : Stops execution, reverts any changes made, Throws an error message
$release     : Each generator function is obliged to write the template $result to $destination file. This operation is denoted by $release
               $release is called automatically at the end of execution if not interrupted by a $return

STD properties:
*************** 
$commentLimitter, 
$attachments, 
$params, 
$required, 
$case, 
$destination, 
$do, 
$delimiter       : Marks where the yaml config ends in a template file. default is #end-conf
 */

/**
 * STD functions used as top level properties are not guarantied to execute in any particular order.
 * use $do property to ensure sequential execution.
 *  $do block is executed after $case block (if any). 
 */

/* default Variables. These are immutable ($result is an exception)
 result, stackPosition, {paramNames}, {imported Function names}
 destination: this is a required and remembered param. asked for, if not set. destination can be empty if we have
 */

/**
 * ANY NON-STD PROPERTY IS SET AS A VARIABLE.
 * this is true inside a case statement too.
 */

 /**
 * Any property except the `$params` can have an evaluation expression (evalExp) `${var-name}` on its key or value side.
 * `$params` can have evalExp only on its right-hand side. Just make sure the param/variable is defined before it is used in an evalExp
 */

/**
 * All committed file changes are reverted if an error is thrown.
 */

/*header*/

$commentLimitter:        #//looks for variable names enclosed in these strings. Default is `/*` and `*/`. Eg: /*varName*/
    - /*$
    - $*/
$attachments:    #// list of files in which reference to the generated file is to be attached and rules for attachment
    hook/path:
        anchor: 
            - /*<-- models -->*/
            - /*<-- models-end -->*/
        glue: ;$endl    #//default is $endl
        hook: require('${p1}')${hook-pattern}

$params:        #// command line params
    p1: Parameter 1
    p2: Parameter 2
    hook-path: Path to file where to hook
    insert-at: pattern of string to attach hook at

$remember: hook-path, insert-at
$required: hook-path, insert-at

/**
 * a `case` or `do` statement can override these properties: 
 * $result, $remember, $destination, $attachments,
 * $attachments can be modified by providing an array of paths(:string) if it is a subset of root $attachments.
 *     if there is change, an object with fields that change.
 */
$case:
    ${p1},${p2},${stackPosition}:
        $null,_,0: 
            - $throw: param 1 can't be empty
        $null,_:
            - $print: Recursion failed
            - $return: $null
        _,test:
            - var1: ${sample 55 68}
            - temp_val: value


#//at the end of execution or when $release called (first occurance only) `${result}` is written to $destination
#//if this field is empty during $release, it'll throw an error and revert all changes.

$destination: path/to/destination/can/must/be/relative/${p1}.js

        // OR
$import:
    -    script1.js
    -    script2.js
$call: init // specs later